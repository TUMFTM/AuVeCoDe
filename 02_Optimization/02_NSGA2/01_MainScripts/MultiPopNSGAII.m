function [state] = MultiPopNSGAII(opt, varargin)
%% Description:
% Designed by: Fabian Liemawan Adji, Adrian König (FTM, Technical University of Munich)
%-------------
% Created on: 01.07.2021
% ------------
% Version: Matlab2020b
%-------------
% Description:  Function defines the optimization options for Multiswarm MOPSO
%               based on NSGA-II by LSSSSWC, NWPU
%               All objectives must be minimization. If a objective is maximization, the
%               objective should be multipled by -1.
% ------------
% Sources:  [1] Fabian Liemawan Adji, “Metaoptimierung von NSGA-II und MOPSO für Fahrzeugkonzeptoptimierung von autonomen elektrischen Fahrzeugen,” Technical University of Munich, Institute of Automotive Technology, 2021
%           [2] Adrian König, "Methodik zur Auslegung von autonomen Fahrzeugkonzepten", Technical University of Munich, Institute of Automotive Technology, 2022
% ------------
% Input:    - nsga2(opt): 'opt' is generated by function nsgaopt().
%           - nsga2(opt, param): 'param' can be any data type, it will be
%             pass to the objective function objfun().
%           - varargin : Additional parameter will be pass to the objective functions.
%             It can be any data type. For example, if you call: nsga2(opt, param),
%             then objfun would be called as objfun(x,param), in which, x is the
%             design variables vector.
% ------------
% Output:   - state : A structure contains optimization state and result.
% ------------
     
    %% Implementation
    
    %% Step 1: Algorithm Initialization
    %*************************************************************************
    % define sorting settings
    %*************************************************************************
    sort_func = @ndsort;        
    
    %*************************************************************************
    % Verify the optimization model
    %*************************************************************************
    opt = verifyOpt(opt);

    %*************************************************************************
    % variables initialization
    %*************************************************************************
    nVar    = opt.numVar;
    nObj    = opt.numObj;
    nCons   = opt.numCons;
    popsize = opt.popsize;

    % pop : current population
    % newpop : new population created by genetic algorithm operators
    % combinepop = pop + newpop;
    pop = repmat( struct(...
        'var', Inf(1,nVar), ...
        'obj', Inf(1,nObj), ...
        'cons', zeros(1,nCons),...
        "age", 0,...
        'rank', Inf,...
        'distance', 0,...
        'prefDistance', 0,...       % preference distance used in R-NSGA-II
        'nViol', 0,...
        'violSum', 0),...
        [1,popsize]);

    % state: optimization state of one generation
    state = struct(...
        'currentGen', 1,...         % current generation number
        'evaluateCount', 0,...      % number of objective function evaluation
        'totalTime', 0,...          % total time from the beginning
        'firstFrontCount', 0,...    % individual number of first front
        'frontCount', 0,...         % number of front
        'avgEvalTime', 0 ...        % average evaluation time of objective function (current generation)
        );


    % global variables
    global STOP_NSGA;   %STOP_NSGA : used in GUI , if STOP_NSGA~=0, then stop the optimizaiton
    STOP_NSGA = 0;
    
    % check the validity of Constant variable Column
    if opt.ConstVarCol < 1 || ~(floor(opt.ConstVarCol)==opt.ConstVarCol)
        error("Constant Variable Column must be a real number");
    end
    
    % set the constant variable column
    opt.ConstVarCol = max(0, opt.ConstVarCol);
    
    
    % initialize plotresult for plotting optimization results
    plotresult.pops     = repmat(pop, [opt.maxGen, 1]);     % each row is the population of one generation
    plotresult.states   = repmat(state, [opt.maxGen, 1]);   % each row is the optimizaiton state of one generation
    plotresult.opt      = opt;                              % use for output

    
    % create a repository for historical Paretos
    ParetoHistory = cell(opt.maxGen,1);
    

    tStart = tic;
    
    %% Step 2: Create sub-swarms for initial state
    %*************************************************************************
    % initialize the P0 population
    %*************************************************************************
    ngen = 1;
    state.currentGen = ngen;
    
    % create a repository to store Pareto individuals from all subpopulations
    Repository.BestIndividuals = [];
    
    % Create subpopulations
    for iPop = 1: opt.SubPopNumbers
        % define subpopulations name
        PopField = "SubPopulation" + string(iPop);
        % create subpopulations struct
        Pop.(PopField) = struct;
        
        % variable to store number of fitness evaluations
        Pop.(PopField).evaluateCount = 0;

        % initialize sub-population
        pop = opt.initfun{1}(opt, pop, opt.initfun{2:end});
        % set the constant column position constant
        pop = struct2table(pop);
        % set the constant column values as constant for current
        % subpopulation
        pop.var(:,opt.ConstVarCol) = iPop;
        pop = table2struct(pop);
        
        % evaluate fitness of all individuals in subpopulation
        [pop, Pop.(PopField)] = evaluate(opt, pop, Pop.(PopField), varargin{:});
        state.evaluateCount = state.evaluateCount + Pop.(PopField).evaluateCount;
        % sort subpopulation by fitness, first sorting must use ndsort
        [opt, pop] = ndsort(opt, pop);

        % add age of all populations by one
        pop = struct2table(pop);
        pop.age = pop.age + 1;

        % find Pareto solutions
        bestpop = pop(pop.rank == 1,:);    
        pop = table2struct(pop);
        
        % store current state of subpopulation in Pop
        Pop.(PopField).pop = pop; % complete population
        Pop.(PopField).Pareto = bestpop; % pareto solutions
        Pop.(PopField).BestPositions = bestpop.var; % variables of pareto
        Pop.(PopField).BestFitness = bestpop.obj; % fitness of pareto
        
        % store the best individuals in repository
        Repository.BestIndividuals = [Repository.BestIndividuals; Pop.(PopField).Pareto];
    end
    
	% sort only unique fitnesses to spare memory
	[~, UniqueFitnessRows] = unique(Repository.BestIndividuals.obj, "rows");
	Repository.BestIndividuals = Repository.BestIndividuals(UniqueFitnessRows, :);
	
    % sort best individuals from all subpopulations
    [opt, Repository.BestIndividuals] = ndsort(opt, table2struct(Repository.BestIndividuals));
    		
	% convert to table to find the best
    Repository.Pareto = struct2table(Repository.BestIndividuals);
    % pareto means best individuals with rank = 1 (nondominated solutions)
    Repository.Pareto = Repository.Pareto(Repository.Pareto.rank == 1,:);
    
    % collect only unique fitnesses to spare memory
    ParetoHistory{ngen} = unique(Repository.Pareto.obj, "rows");
	
	% update state
    state.currentGen = ngen;
    state.totalTime = toc(tStart);
    state = statpop(Repository.BestIndividuals, state);
    
    % prepare message for waitbar
    Message = sprintf("Iteration %i / %i",...
                        ngen, opt.maxGen);
    % initialize waitbar
    ShowMe = waitbar(0,Message);
    
    % prepare plotresult data for plotting optimization results
    plotresult.pops(1, 1:height(Repository.BestIndividuals)) = Repository.BestIndividuals;
    plotresult.states(1)  = state;

    % plot optimization result for first generation
    plotnsga(plotresult, ngen);

    
    %% Step 3: Iterate until the maximal iteration
    %*************************************************************************
    % NSGA2 iteration
    %*************************************************************************
    while ngen < opt.maxGen
         % 0. Display some information
        ngen = ngen+1;
        state.currentGen = ngen;
        fprintf('\n\n************************************************************\n');
        fprintf('*      Current generation %d / %d\n', ngen, opt.maxGen);
        fprintf('************************************************************\n');
        
        % convert best individual from struct to table to allow
        % contacenation
        Repository.BestIndividuals = struct2table(Repository.BestIndividuals);
        
        % iteration for each subpopulations
        for iPop = 1: opt.SubPopNumbers
            % define subpopulation name
            PopField = "SubPopulation" + string(iPop);
            
            % 1. Create new population
            % selection: select the best individuals of old population
            newpop = selectOp(opt, Pop.(PopField).pop);
            % crossover of the selected individuals
            newpop = crossoverOp(opt, newpop, state);
            % mutation of the selected individuals
            newpop = mutationOp(opt, newpop, state);
            
            % set the constant column values as constant for current
            % subpopulation
            newpop = struct2table(newpop);
            newpop.var(:,opt.ConstVarCol) = iPop;
            newpop = table2struct(newpop);
            
            % evaluate the fitness of the new subpopulation
            [newpop, Pop.(PopField)] = evaluate(opt, newpop, Pop.(PopField), varargin{:});
            state.evaluateCount = state.evaluateCount + Pop.(PopField).evaluateCount;

            % set age of new pop to 0
            newpop = struct2table(newpop);
            newpop.age = zeros(height(newpop),1);
            newpop = table2struct(newpop);
            
            % secure size, otherwise error may occure in sorting function
            if size(newpop,2) ~= size(pop,2)
                newpop = newpop';
            end
            
            % 2. Combine the new population and old population : combinepop = pop + newpop
            combinepop = [Pop.(PopField).pop; newpop];
            
            % 3. Fast non dominated sort
            [opt, combinepop] = sort_func(opt, combinepop);
            
            % 4. Extract the next population
            pop = extractPop(opt, combinepop);

            % add age of all populations by one
            pop = struct2table(pop);
            pop.age = pop.age + 1;
            
            % find Pareto solutions
            bestpop = pop(pop.rank == 1,:);    
            pop = table2struct(pop);
            
            % store current state of subpopulation in Pop
            Pop.(PopField).pop = pop; % complete population
            Pop.(PopField).Pareto = bestpop; % pareto solutions
            Pop.(PopField).BestPositions = bestpop.var; % variables of pareto
            Pop.(PopField).BestFitness = bestpop.obj; % fitness of pareto

            % store the best individuals in repository
            Repository.BestIndividuals = [Repository.BestIndividuals; Pop.(PopField).Pareto];
        end
        
		% sort only unique fitnesses to spare memory
		[~, UniqueFitnessRows] = unique(Repository.BestIndividuals.obj, "rows");
        % pareto means best individuals with rank = 1 (nondominated solutions)
		Repository.BestIndividuals = Repository.BestIndividuals(UniqueFitnessRows, :);
		
        % sort best individuals from all subpopulations
        [opt, Repository.BestIndividuals] = ndsort(opt, table2struct(Repository.BestIndividuals));
        % convert to table to find the best
        Repository.Pareto = struct2table(Repository.BestIndividuals);
        Repository.Pareto = Repository.Pareto(Repository.Pareto.rank == 1,:);
		
		% update state
		state.currentGen = ngen;
		state.totalTime = toc(tStart);
		state = statpop(Repository.BestIndividuals, state);

        % collect only unique fitnesses to spare memory
        ParetoHistory{ngen} = unique(Repository.Pareto.obj, "rows");
        
        % prepare message for waitbar
        Message = sprintf("Iteration %i / %i:",...
                ngen, opt.maxGen);
        % show current optimization progress
        waitbar(ngen/opt.maxGen, ShowMe,  Message);

        % prepare plotresult data for plotting optimization results
        plotresult.pops(ngen, 1:height(Repository.BestIndividuals)) = Repository.BestIndividuals;
        plotresult.states(ngen)  = state;

        % plot optimization result for current generation
        plotnsga(plotresult, ngen);
    end
    
    % close waitbar
    close(ShowMe);
    
    % calculate total time
    tEnd = toc(tStart);
    state.totaltime = tEnd;
    
    % store number of generations
    state.generations = ngen;
       
    % save the best fitness
    result.bestFitness =  Repository.Pareto.obj;
    
    % find the best position
    result.bestPosition = Repository.Pareto.var;
    
    % store pareto history for evaluations
    result.ParetoHistory = ParetoHistory;
    
    % store results in state
    state.result = result;
    % store options in state
    state.opt = opt;
    % store all subpopulations data in state
    state.pop = Pop;
    % store repository in state
    state.Repository = Repository;
    
    % save Parameters in state
    Parameters=varargin{1, 1};
    state.Parameters = Parameters;
end
