function [state] = nsga2(opt, varargin)
    % Function: result = nsga2(opt, varargin)
    % Description: The main flowchart of of NSGA-II. Note:
    %   All objectives must be minimization. If a objective is maximization, the
    %   objective should be multipled by -1.
    %
    % Syntax:
    %   result = nsga2(opt): 'opt' is generated by function nsgaopt().
    %   result = nsga2(opt, param): 'param' can be any data type, it will be
    %       pass to the objective function objfun().
    %
    %   Then ,the result structure can be pass to plotnsga to display the
    %   population:  plotnsga(result);
    %
    % Parameters:
    %   opt : A structure generated by funciton nsgaopt().
    %   varargin : Additional parameter will be pass to the objective functions.
    %       It can be any data type. For example, if you call: nsga2(opt, param),
    %       then objfun would be called as objfun(x,param), in which, x is the
    %       design variables vector.
    % Return:
    %   state : A structure contains optimization state and result.
    %
    %         LSSSSWC, NWPU
    %   Revision: 1.2  Data: 2011-07-26
    %*************************************************************************

    % Last modification:    Fabian Liemawan Adji (July 2021)
    % Sources: [1] Fabian Liemawan Adji, “Metaoptimierung von NSGA-II und MOPSO für Fahrzeugkonzeptoptimierung von autonomen elektrischen Fahrzeugen,” Technical University of Munich, Institute of Automotive Technology, 2021
    
    
    %*************************************************************************
    % define sorting settings
    %*************************************************************************
    sort_func = @ndsort;        
    
    %*************************************************************************
    % Verify the optimization model
    %*************************************************************************
    opt = verifyOpt(opt);

    %*************************************************************************
    % variables initialization
    %*************************************************************************
    nVar    = opt.numVar;
    nObj    = opt.numObj;
    nCons   = opt.numCons;
    popsize = opt.popsize;

    % pop : current population
    % newpop : new population created by genetic algorithm operators
    % combinepop = pop + newpop;
    pop = repmat( struct(...
        'var', zeros(1,nVar), ...
        'obj', zeros(1,nObj), ...
        'cons', zeros(1,nCons),...
        "age", 0,...
        'rank', 0,...
        'distance', 0,...
        'prefDistance', 0,...       % preference distance used in R-NSGA-II
        'nViol', 0,...
        'violSum', 0),...
        [1,popsize]);

    % state: optimization state of one generation
    state = struct(...
        'currentGen', 1,...         % current generation number
        'evaluateCount', 0,...      % number of objective function evaluation
        'totalTime', 0,...          % total time from the beginning
        'firstFrontCount', 0,...    % individual number of first front
        'frontCount', 0,...         % number of front
        'avgEvalTime', 0 ...        % average evaluation time of objective function (current generation)
        );

    % create a repository for historical Paretos
    ParetoHistory = cell(opt.maxGen,1);


    % global variables
    global STOP_NSGA;   %STOP_NSGA : used in GUI , if STOP_NSGA~=0, then stop the optimizaiton
    STOP_NSGA = 0;
    
    % initialize plotresult for plotting optimization results
    plotresult.pops     = repmat(pop, [opt.maxGen, 1]);     % each row is the population of one generation
    plotresult.states   = repmat(state, [opt.maxGen, 1]);   % each row is the optimizaiton state of one generation
    plotresult.opt      = opt;                              % use for output

    tStart = tic;
    %*************************************************************************
    % initialize the P0 population
    %*************************************************************************
    % initial condition : first generation
    ngen = 1;
    % Initialize population
    pop = opt.initfun{1}(opt, pop, opt.initfun{2:end});
    % evaluate individuals fitness in population
    [pop, state] = evaluate(opt, pop, state, varargin{:});
    % sort population by fitness, first sorting must use ndsort
    [opt, pop] = ndsort(opt, pop);

    % update state
    state.currentGen = ngen;
    state.totalTime = toc(tStart);
    state = statpop(pop, state);

    % convert to table temporarily for easier handling
    pop = struct2table(pop);
    % derive the pareto population
    pareto_pop = pop(pop.rank == 1,:);
    % store the pareto objectives in ParetoHistory for evaluation
    ParetoHistory{ngen} = pareto_pop.obj;
    % add age of all populations by one
    pop.age = pop.age + 1;
    pop = table2struct(pop);

    % prepare plotresult data for plotting optimization results
    plotresult.pops(1, :) = pop;
    plotresult.states(1)  = state;

    % plot optimization result for first generation
    plotnsga(plotresult, ngen);    
    
    opt = callOutputfuns(opt, state, pop);
    
    Message = sprintf("Iteration %i / %i",...
                        ngen, opt.maxGen);
    ShowMe = waitbar(0,Message);

    %*************************************************************************
    % NSGA2 iteration
    %*************************************************************************
    while ngen < opt.maxGen
        % 0. Display some information
        ngen = ngen+1;
        state.currentGen = ngen;
        fprintf('\n\n************************************************************\n');
        fprintf('*      Current generation %d / %d\n', ngen, opt.maxGen);
        fprintf('************************************************************\n');

        % 1. Create new population
        % selection: select the best individuals of old population
        newpop = selectOp(opt, pop);
        % crossover of the selected individuals
        newpop = crossoverOp(opt, newpop, state);
        % mutation of the selected individuals
        newpop = mutationOp(opt, newpop, state);
        % evaluate the fitness of the new population
        [newpop, state] = evaluate(opt, newpop, state, varargin{:});

        % set age of new pop to 0
        newpop = struct2table(newpop);
        newpop.age = zeros(height(newpop),1);
        newpop = table2struct(newpop);
        
        % secure size, otherwise error may occure in sorting function
        if size(newpop,2) ~= size(pop,2)
            newpop = newpop';
        end

        % 2. Combine the new population and old population : combinepop = pop + newpop
        combinepop = [pop; newpop];

        % 3. Fast non dominated sort
        [opt, combinepop] = sort_func(opt, combinepop);

        % 4. Extract the next population
        pop = extractPop(opt, combinepop);

        % convert to table temporarily for easier handling
        pop = struct2table(pop);
        % derive the pareto population
        pareto_pop = pop(pop.rank == 1,:);
        % store the pareto objectives in ParetoHistory for evaluation
        ParetoHistory{ngen} = pareto_pop.obj;
        % add age of all populations by one
        pop.age = pop.age + 1;
        pop = table2struct(pop);


        % 5. Save current generation results
        state.totalTime = toc(tStart);
        state = statpop(pop, state);

        Message = sprintf("Iteration %i / %i",...
                    ngen, opt.maxGen);
        waitbar(ngen/opt.maxGen, ShowMe,  Message);
        
        % prepare plotresult data for plotting optimization results
        plotresult.pops(ngen, :) = pop;
        plotresult.states(ngen)  = state;
        
        % plot optimization result for current generation
        plotnsga(plotresult, ngen);

        if( mod(ngen, opt.outputInterval)==0 )
           opt = callOutputfuns(opt, state, pop);
        end

    end
    % close waitbar
    close(ShowMe);
    
    % calculate total time
    tEnd = toc(tStart);
    state.totaltime = tEnd;
    
    % store number of generations
    state.generations = ngen;
    
    % find the best position
    result.bestPosition = pareto_pop.var;
    % save the best fitness
    result.bestFitness = pareto_pop.obj;
    
    % store pareto history for evaluations
    result.ParetoHistory = ParetoHistory;
    % store results in state
    state.result = result;
    % store options in state
    state.options = opt;
    % store all population data in state
    state.pop = pop;

    % call output function for closing file
    opt = callOutputfuns(opt, state, pop, -1);

    % save Parameters in state
    Parameters=varargin{1, 1};
    state.Parameters = Parameters;

    % close worker processes
    try
        if( strcmpi(opt.useParallel, 'yes'))
            delete(gcp("nocreate"));
        end
    catch
        disp('Warning: Parallel Computing was not active (Toolbox is prob. not installed)')
    end

end
